#!/usr/bin/env node

import * as fs from 'fs';
import * as path from 'path';
import * as yaml from 'js-yaml';

// Constants
const SOURCE_DIR = path.join(process.cwd(), 'design-tokens', 'source');
const OUTPUT_DIR = path.join(process.cwd(), 'generated');
const CSS_PREFIX = '--vergil-';
const PACKAGE_VERSION = '1.0.0';

// Token reference pattern
const TOKEN_REF_PATTERN = /\{([^}]+)\}/g;

// Ensure output directory exists
if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}

// Types
interface TokenValue {
  value: string;
  comment?: string;
  deprecated?: boolean;
}

interface TokenGroup {
  [key: string]: TokenValue | TokenGroup;
}

interface TokenData {
  [key: string]: TokenGroup;
}

// Utility functions
function kebabToCamel(str: string): string {
  return str.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
}

function flattenTokens(obj: TokenGroup, prefix: string = ''): Record<string, TokenValue> {
  const result: Record<string, TokenValue> = {};
  
  for (const [key, value] of Object.entries(obj)) {
    const tokenPath = prefix ? `${prefix}.${key}` : key;
    
    if (value && typeof value === 'object' && 'value' in value) {
      // This is a token value
      result[tokenPath] = value as TokenValue;
    } else if (value && typeof value === 'object' && ('x' in value || 'y' in value)) {
      // This is a complex token (like inset with x/y)
      const complexValue = value as any;
      if ('x' in complexValue && 'y' in complexValue) {
        result[`${tokenPath}.x`] = { value: complexValue.x, comment: complexValue.comment };
        result[`${tokenPath}.y`] = { value: complexValue.y, comment: complexValue.comment };
      }
    } else if (value && typeof value === 'object') {
      // This is a nested group
      Object.assign(result, flattenTokens(value as TokenGroup, tokenPath));
    }
  }
  
  return result;
}

function resolveTokenReferences(tokens: Record<string, TokenValue>): Record<string, TokenValue> {
  const resolved: Record<string, TokenValue> = {};
  const resolveStack: Set<string> = new Set();
  
  function findToken(refPath: string): string | null {
    // First try exact match
    if (tokens[refPath]) {
      return refPath;
    }
    
    // Try with different category prefixes
    const possiblePrefixes = ['colors', 'spacing', 'typography', 'shadows', 'animations'];
    for (const prefix of possiblePrefixes) {
      const fullPath = `${prefix}.${refPath}`;
      if (tokens[fullPath]) {
        return fullPath;
      }
    }
    
    return null;
  }
  
  function resolveValue(tokenPath: string): string {
    if (resolveStack.has(tokenPath)) {
      throw new Error(`Circular reference detected: ${Array.from(resolveStack).join(' -> ')} -> ${tokenPath}`);
    }
    
    resolveStack.add(tokenPath);
    
    const token = tokens[tokenPath];
    if (!token) {
      throw new Error(`Token not found: ${tokenPath}`);
    }
    
    let value = token.value;
    
    // Ensure value is a string before processing
    if (typeof value !== 'string') {
      console.warn(`Warning: Token ${tokenPath} has non-string value:`, value);
      resolveStack.delete(tokenPath);
      return String(value);
    }
    
    // Resolve any references in the value
    value = value.replace(TOKEN_REF_PATTERN, (match, ref) => {
      const refPath = ref.trim();
      const actualPath = findToken(refPath);
      
      if (!actualPath) {
        throw new Error(`Token reference not found: ${refPath} (referenced from ${tokenPath})`);
      }
      
      return resolveValue(actualPath);
    });
    
    resolveStack.delete(tokenPath);
    return value;
  }
  
  // Resolve all tokens
  for (const [path, token] of Object.entries(tokens)) {
    resolved[path] = {
      ...token,
      value: resolveValue(path)
    };
  }
  
  return resolved;
}

// Load all YAML files
function loadTokens(): TokenData {
  const allTokens: TokenData = {};
  
  const files = fs.readdirSync(SOURCE_DIR).filter(f => f.endsWith('.yaml') || f.endsWith('.yml'));
  
  for (const file of files) {
    const filePath = path.join(SOURCE_DIR, file);
    const content = fs.readFileSync(filePath, 'utf8');
    const data = yaml.load(content) as TokenData;
    
    // Merge tokens
    for (const [category, tokens] of Object.entries(data)) {
      if (!allTokens[category]) {
        allTokens[category] = {};
      }
      Object.assign(allTokens[category], tokens);
    }
  }
  
  return allTokens;
}

// Generate CSS custom properties
function generateCSS(tokens: Record<string, TokenValue>): string {
  const lines: string[] = [
    '/**',
    ' * Vergil Design System - CSS Custom Properties',
    ` * Generated: ${new Date().toISOString()}`,
    ` * Version: ${PACKAGE_VERSION}`,
    ' * DO NOT EDIT - This file is automatically generated from YAML sources',
    ' */',
    '',
    ':root {'
  ];
  
  const sortedTokens = Object.entries(tokens).sort(([a], [b]) => a.localeCompare(b));
  
  for (const [path, token] of sortedTokens) {
    if (token.deprecated) continue;
    
    const cssVar = CSS_PREFIX + path.replace(/\./g, '-');
    
    if (token.comment) {
      lines.push(`  /* ${token.comment} */`);
    }
    lines.push(`  ${cssVar}: ${token.value};`);
  }
  
  lines.push('}');
  
  return lines.join('\n');
}

// Generate TypeScript constants
function generateTypeScript(tokens: Record<string, TokenValue>): string {
  const lines: string[] = [
    '/**',
    ' * Vergil Design System - TypeScript Token Constants',
    ` * Generated: ${new Date().toISOString()}`,
    ` * Version: ${PACKAGE_VERSION}`,
    ' * DO NOT EDIT - This file is automatically generated from YAML sources',
    ' */',
    '',
    '// Token values as nested object',
    'export const tokens = {'
  ];
  
  // Build nested structure
  const nested: any = {};
  
  for (const [path, token] of Object.entries(tokens)) {
    if (token.deprecated) continue;
    
    const parts = path.split('.');
    let current = nested;
    
    for (let i = 0; i < parts.length - 1; i++) {
      const part = kebabToCamel(parts[i]);
      if (!current[part] || typeof current[part] !== 'object') {
        current[part] = {};
      }
      current = current[part];
    }
    
    const lastPart = kebabToCamel(parts[parts.length - 1]);
    // Only set if it's not already an object (avoid overwriting)
    if (typeof current[lastPart] !== 'object') {
      current[lastPart] = token.value;
    }
  }
  
  // Convert to string with proper formatting
  const nestedStr = JSON.stringify(nested, null, 2)
    .replace(/"([^"]+)":/g, '$1:')
    .replace(/"/g, "'");
  
  // Remove the opening brace since we already have it
  const contentLines = nestedStr.split('\n').slice(1, -1);
  lines.push(...contentLines.map(line => '  ' + line));
  lines.push('} as const;');
  lines.push('');
  
  // Generate type definitions
  lines.push('// Type definitions');
  lines.push('export type TokenValue = string;');
  lines.push('');
  
  // Generate token paths type
  const tokenPaths = Object.keys(tokens)
    .filter(path => !tokens[path].deprecated)
    .map(path => `'${path}'`);
  
  lines.push('export type TokenPath =');
  tokenPaths.forEach((path, i) => {
    const prefix = i === 0 ? '  | ' : '  | ';
    lines.push(prefix + path);
  });
  lines.push(';');
  lines.push('');
  
  // CSS variable helper
  lines.push('// CSS variable helper');
  lines.push('export function getCSSVar(path: TokenPath): string {');
  lines.push(`  return 'var(${CSS_PREFIX}' + path.replace(/\\./g, '-') + ')';`);
  lines.push('}');
  
  return lines.join('\n');
}

// Generate JSON output
function generateJSON(tokens: Record<string, TokenValue>): string {
  const output = {
    version: PACKAGE_VERSION,
    generated: new Date().toISOString(),
    tokens: {}
  };
  
  // Build nested structure
  for (const [path, token] of Object.entries(tokens)) {
    const parts = path.split('.');
    let current: any = output.tokens;
    
    for (let i = 0; i < parts.length - 1; i++) {
      if (!current[parts[i]]) {
        current[parts[i]] = {};
      }
      current = current[parts[i]];
    }
    
    current[parts[parts.length - 1]] = {
      value: token.value,
      ...(token.comment && { comment: token.comment }),
      ...(token.deprecated && { deprecated: token.deprecated })
    };
  }
  
  return JSON.stringify(output, null, 2);
}

// Generate Tailwind theme extension
function generateTailwindTheme(tokens: Record<string, TokenValue>): string {
  const lines: string[] = [
    '/**',
    ' * Vergil Design System - Tailwind Theme Extension',
    ` * Generated: ${new Date().toISOString()}`,
    ` * Version: ${PACKAGE_VERSION}`,
    ' * DO NOT EDIT - This file is automatically generated from YAML sources',
    ' */',
    '',
    'module.exports = {'
  ];
  
  // Extract specific token categories for Tailwind
  const colors: any = {};
  const spacing: any = {};
  const borderRadius: any = {};
  
  for (const [path, token] of Object.entries(tokens)) {
    if (token.deprecated) continue;
    
    const parts = path.split('.');
    
    if (parts[0] === 'colors') {
      // Handle colors
      let current = colors;
      for (let i = 1; i < parts.length - 1; i++) {
        if (!current[parts[i]]) {
          current[parts[i]] = {};
        }
        current = current[parts[i]];
      }
      current[parts[parts.length - 1]] = token.value;
    } else if (parts[0] === 'spacing' && parts[1] === 'scale') {
      // Handle spacing scale
      spacing[parts[2]] = token.value;
    } else if (parts[0] === 'spacing' && parts[1] === 'radius') {
      // Handle border radius
      borderRadius[parts[2]] = token.value;
    }
  }
  
  lines.push('  colors: ' + JSON.stringify(colors, null, 4).split('\n').map((line, i) => i === 0 ? line : '  ' + line).join('\n') + ',');
  lines.push('  spacing: ' + JSON.stringify(spacing, null, 4).split('\n').map((line, i) => i === 0 ? line : '  ' + line).join('\n') + ',');
  lines.push('  borderRadius: ' + JSON.stringify(borderRadius, null, 4).split('\n').map((line, i) => i === 0 ? line : '  ' + line).join('\n'));
  lines.push('};');
  
  return lines.join('\n');
}

// Generate SCSS variables
function generateSCSS(tokens: Record<string, TokenValue>): string {
  const lines: string[] = [
    '/**',
    ' * Vergil Design System - SCSS Variables',
    ` * Generated: ${new Date().toISOString()}`,
    ` * Version: ${PACKAGE_VERSION}`,
    ' * DO NOT EDIT - This file is automatically generated from YAML sources',
    ' */',
    ''
  ];
  
  const sortedTokens = Object.entries(tokens).sort(([a], [b]) => a.localeCompare(b));
  
  for (const [path, token] of sortedTokens) {
    if (token.deprecated) continue;
    
    const scssVar = '$vergil-' + path.replace(/\./g, '-');
    
    if (token.comment) {
      lines.push(`// ${token.comment}`);
    }
    lines.push(`${scssVar}: ${token.value};`);
  }
  
  return lines.join('\n');
}

// Main build function
async function build() {
  console.log('🔨 Building design tokens...');
  
  try {
    // Load tokens
    const rawTokens = loadTokens();
    console.log('✅ Loaded token files');
    
    // Flatten tokens
    const flatTokens = flattenTokens(rawTokens);
    console.log(`✅ Flattened ${Object.keys(flatTokens).length} tokens`);
    
    
    // Resolve references
    const resolvedTokens = resolveTokenReferences(flatTokens);
    console.log('✅ Resolved token references');
    
    // Generate outputs
    const outputs = [
      { file: 'tokens.css', content: generateCSS(resolvedTokens) },
      { file: 'tokens.ts', content: generateTypeScript(resolvedTokens) },
      { file: 'tokens.json', content: generateJSON(resolvedTokens) },
      { file: 'tailwind-theme.js', content: generateTailwindTheme(resolvedTokens) },
      { file: 'tokens.scss', content: generateSCSS(resolvedTokens) }
    ];
    
    // Write outputs
    for (const { file, content } of outputs) {
      const outputPath = path.join(OUTPUT_DIR, file);
      fs.writeFileSync(outputPath, content);
      console.log(`✅ Generated ${file}`);
    }
    
    console.log(`\n🎉 Successfully built ${outputs.length} token files!`);
    console.log(`📁 Output directory: ${OUTPUT_DIR}`);
    
  } catch (error) {
    console.error('❌ Build failed:', error);
    process.exit(1);
  }
}

// Watch mode
function watch() {
  console.log('👀 Watching for changes...');
  
  const watchDir = SOURCE_DIR;
  let timeout: NodeJS.Timeout;
  
  fs.watch(watchDir, { recursive: true }, (eventType, filename) => {
    if (!filename?.endsWith('.yaml') && !filename?.endsWith('.yml')) return;
    
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      console.log(`\n🔄 Change detected in ${filename}`);
      build();
    }, 100);
  });
  
  // Initial build
  build();
}

// CLI handling
const args = process.argv.slice(2);
const isWatch = args.includes('--watch') || args.includes('-w');

if (isWatch) {
  watch();
} else {
  build();
}