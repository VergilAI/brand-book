/**
 * Token Exporter - Export tokens to various formats
 */

import { writeFileSync, mkdirSync, existsSync } from 'fs';
import { join, dirname } from 'path';
import {
  TokenDefinition,
  TokenRegistry,
  ExportOptions,
  ExportResult,
  TokenCategory
} from './types.js';

export class TokenExporter {
  private outputDir: string;

  constructor(outputDir: string = 'generated') {
    this.outputDir = outputDir;
    this.ensureOutputDir();
  }

  /**
   * Export tokens in specified format
   */
  async export(registry: TokenRegistry, options: ExportOptions): Promise<ExportResult> {
    const tokens = this.filterTokens(registry, options);
    let content: string;
    let filename: string;

    switch (options.format) {
      case 'css':
        content = this.generateCSS(tokens, options);
        filename = 'tokens.css';
        break;
      case 'scss':
        content = this.generateSCSS(tokens, options);
        filename = 'tokens.scss';
        break;
      case 'js':
        content = this.generateJavaScript(tokens, options);
        filename = 'tokens.js';
        break;
      case 'ts':
        content = this.generateTypeScript(tokens, options);
        filename = 'tokens.ts';
        break;
      case 'json':
        content = this.generateJSON(tokens, options);
        filename = 'tokens.json';
        break;
      case 'yaml':
        content = this.generateYAML(tokens, options);
        filename = 'tokens.yaml';
        break;
      case 'tailwind':
        content = this.generateTailwindConfig(tokens, options);
        filename = 'tailwind-tokens.js';
        break;
      default:
        throw new Error(`Unsupported export format: ${options.format}`);
    }

    // Minify if requested
    if (options.minify && (options.format === 'css' || options.format === 'js')) {
      content = this.minify(content, options.format);
    }

    // Write file
    const filePath = join(this.outputDir, filename);
    writeFileSync(filePath, content, 'utf-8');

    return {
      content,
      filename: filePath,
      format: options.format,
      metadata: {
        tokenCount: tokens.length,
        categories: [...new Set(tokens.map(t => t.category))],
        timestamp: new Date().toISOString()
      }
    };
  }

  /**
   * Export all formats
   */
  async exportAll(registry: TokenRegistry): Promise<ExportResult[]> {
    const formats: ExportOptions['format'][] = ['css', 'scss', 'ts', 'json', 'tailwind'];
    const results: ExportResult[] = [];

    for (const format of formats) {
      try {
        const result = await this.export(registry, { 
          format, 
          includeComments: true,
          includeDeprecated: false 
        });
        results.push(result);
      } catch (error) {
        console.warn(`Failed to export ${format}:`, error);
      }
    }

    return results;
  }

  /**
   * Filter tokens based on export options
   */
  private filterTokens(registry: TokenRegistry, options: ExportOptions): TokenDefinition[] {
    let tokens: TokenDefinition[] = [];

    // Collect tokens from specified categories or all
    const categoriesToInclude = options.categories || Object.keys(registry.categories) as TokenCategory[];
    
    for (const categoryName of categoriesToInclude) {
      const category = registry.categories[categoryName];
      if (category) {
        tokens.push(...category.tokens);
      }
    }

    // Filter deprecated tokens
    if (!options.includeDeprecated) {
      tokens = tokens.filter(token => !token.deprecated);
    }

    // Sort tokens
    tokens.sort((a, b) => {
      // Sort by category first, then by name
      if (a.category !== b.category) {
        return a.category.localeCompare(b.category);
      }
      return a.name.localeCompare(b.name);
    });

    return tokens;
  }

  /**
   * Generate CSS custom properties
   */
  private generateCSS(tokens: TokenDefinition[], options: ExportOptions): string {
    const lines: string[] = [];

    // Header
    lines.push('/**');
    lines.push(' * Design System Tokens - CSS Custom Properties');
    lines.push(` * Generated: ${new Date().toISOString()}`);
    lines.push(' * DO NOT EDIT - This file is automatically generated');
    lines.push(' */');
    lines.push('');

    // Root declaration
    lines.push(':root {');

    // Group by category
    const tokensByCategory = this.groupByCategory(tokens);
    
    for (const [categoryName, categoryTokens] of Object.entries(tokensByCategory)) {
      if (categoryTokens.length === 0) continue;

      lines.push('');
      lines.push(`  /* ${categoryName.toUpperCase()} */`);

      for (const token of categoryTokens) {
        if (options.includeComments && token.comment) {
          lines.push(`  /* ${token.comment} */`);
        }

        const varName = options.prefix ? `--${options.prefix}-${token.name}` : token.cssVar;
        lines.push(`  ${varName}: ${token.value};`);

        if (token.deprecated && options.includeComments) {
          lines.push(`  /* ⚠️ DEPRECATED: Use alternative token */`);
        }
      }
    }

    lines.push('}');

    // Add utility classes if requested
    if (options.includeComments) {
      lines.push('');
      lines.push('/* Utility classes for quick access */');
      lines.push('.token-vars {');
      for (const token of tokens.slice(0, 10)) { // Limit examples
        const className = `.${token.name.replace(/([A-Z])/g, '-$1').toLowerCase()}`;
        if (token.type === 'color') {
          lines.push(`  /* ${className} { color: var(${token.cssVar}); } */`);
        }
      }
      lines.push('}');
    }

    return lines.join('\n');
  }

  /**
   * Generate SCSS variables
   */
  private generateSCSS(tokens: TokenDefinition[], options: ExportOptions): string {
    const lines: string[] = [];

    // Header
    lines.push('//');
    lines.push('// Design System Tokens - SCSS Variables');
    lines.push(`// Generated: ${new Date().toISOString()}`);
    lines.push('// DO NOT EDIT - This file is automatically generated');
    lines.push('//');
    lines.push('');

    // Group by category
    const tokensByCategory = this.groupByCategory(tokens);
    
    for (const [categoryName, categoryTokens] of Object.entries(tokensByCategory)) {
      if (categoryTokens.length === 0) continue;

      lines.push(`// ${categoryName.toUpperCase()}`);
      lines.push('// ' + '='.repeat(40));

      for (const token of categoryTokens) {
        if (options.includeComments && token.comment) {
          lines.push(`// ${token.comment}`);
        }

        const varName = options.prefix ? `$${options.prefix}-${token.name}` : `$${token.name}`;
        lines.push(`${varName}: ${token.value};`);

        if (token.deprecated && options.includeComments) {
          lines.push(`// ⚠️ DEPRECATED: Use alternative token`);
        }
      }
      lines.push('');
    }

    // Add SCSS map
    lines.push('// Token map for programmatic access');
    lines.push('$tokens: (');
    for (const token of tokens) {
      const key = token.name.replace(/-/g, '_');
      lines.push(`  "${key}": ${token.value},`);
    }
    lines.push(');');

    return lines.join('\n');
  }

  /**
   * Generate TypeScript constants
   */
  private generateTypeScript(tokens: TokenDefinition[], options: ExportOptions): string {
    const lines: string[] = [];

    // Header
    lines.push('/**');
    lines.push(' * Design System Tokens - TypeScript');
    lines.push(` * Generated: ${new Date().toISOString()}`);
    lines.push(' * DO NOT EDIT - This file is automatically generated');
    lines.push(' */');
    lines.push('');

    // Type definitions
    lines.push('export type TokenValue = string;');
    lines.push('export type TokenCategory = ' + 
      Object.keys(this.groupByCategory(tokens))
        .map(cat => `'${cat}'`)
        .join(' | ') + ';');
    lines.push('');

    // Token paths type
    const tokenPaths = tokens.map(t => `'${t.path}'`);
    lines.push('export type TokenPath =');
    tokenPaths.forEach((path, i) => {
      const prefix = i === 0 ? '  | ' : '  | ';
      lines.push(prefix + path);
    });
    lines.push(';');
    lines.push('');

    // Tokens object
    lines.push('export const tokens = {');
    
    const tokensByCategory = this.groupByCategory(tokens);
    const categoryEntries = Object.entries(tokensByCategory);
    
    for (const [categoryName, categoryTokens] of categoryEntries) {
      if (categoryTokens.length === 0) continue;
      
      lines.push(`  ${categoryName}: {`);
      
      for (const token of categoryTokens) {
        if (options.includeComments && token.comment) {
          lines.push(`    /** ${token.comment} */`);
        }
        if (token.deprecated && options.includeComments) {
          lines.push(`    /** @deprecated Use alternative token */`);
        }
        
        const key = this.toCamelCase(token.name);
        lines.push(`    ${key}: '${token.value}',`);
      }
      
      lines.push('  },');
    }
    
    lines.push('} as const;');
    lines.push('');

    // Helper functions
    lines.push('/**');
    lines.push(' * Get CSS variable for token');
    lines.push(' */');
    lines.push('export function getCSSVar(path: TokenPath): string {');
    lines.push('  return `var(--${path.replace(/\\./g, "-")})`;');
    lines.push('}');
    lines.push('');

    lines.push('/**');
    lines.push(' * Get token value by path');
    lines.push(' */');
    lines.push('export function getToken(path: TokenPath): TokenValue {');
    lines.push('  const parts = path.split(".");');
    lines.push('  let current: any = tokens;');
    lines.push('  for (const part of parts) {');
    lines.push('    current = current[part];');
    lines.push('    if (current === undefined) throw new Error(`Token not found: ${path}`);');
    lines.push('  }');
    lines.push('  return current;');
    lines.push('}');

    return lines.join('\n');
  }

  /**
   * Generate JavaScript constants
   */
  private generateJavaScript(tokens: TokenDefinition[], options: ExportOptions): string {
    const lines: string[] = [];

    // Header
    lines.push('/**');
    lines.push(' * Design System Tokens - JavaScript');
    lines.push(` * Generated: ${new Date().toISOString()}`);
    lines.push(' * DO NOT EDIT - This file is automatically generated');
    lines.push(' */');
    lines.push('');

    // Tokens object
    lines.push('export const tokens = {');
    
    const tokensByCategory = this.groupByCategory(tokens);
    
    for (const [categoryName, categoryTokens] of Object.entries(tokensByCategory)) {
      if (categoryTokens.length === 0) continue;
      
      lines.push(`  ${categoryName}: {`);
      
      for (const token of categoryTokens) {
        if (options.includeComments && token.comment) {
          lines.push(`    // ${token.comment}`);
        }
        
        const key = this.toCamelCase(token.name);
        lines.push(`    ${key}: '${token.value}',`);
      }
      
      lines.push('  },');
    }
    
    lines.push('};');
    lines.push('');

    // Helper functions
    lines.push('export function getCSSVar(path) {');
    lines.push('  return `var(--${path.replace(/\\./g, "-")})`;');
    lines.push('}');

    return lines.join('\n');
  }

  /**
   * Generate JSON format
   */
  private generateJSON(tokens: TokenDefinition[], options: ExportOptions): string {
    const data = {
      version: '1.0.0',
      generated: new Date().toISOString(),
      tokens: this.groupByCategory(tokens)
    };

    return JSON.stringify(data, null, 2);
  }

  /**
   * Generate YAML format
   */
  private generateYAML(tokens: TokenDefinition[], options: ExportOptions): string {
    const lines: string[] = [];

    lines.push('# Design System Tokens - YAML');
    lines.push(`# Generated: ${new Date().toISOString()}`);
    lines.push('# DO NOT EDIT - This file is automatically generated');
    lines.push('');

    lines.push('version: "1.0.0"');
    lines.push(`generated: "${new Date().toISOString()}"`);
    lines.push('');

    lines.push('tokens:');
    
    const tokensByCategory = this.groupByCategory(tokens);
    
    for (const [categoryName, categoryTokens] of Object.entries(tokensByCategory)) {
      if (categoryTokens.length === 0) continue;
      
      lines.push(`  ${categoryName}:`);
      
      for (const token of categoryTokens) {
        lines.push(`    ${token.name}:`);
        lines.push(`      value: "${token.value}"`);
        lines.push(`      type: "${token.type}"`);
        
        if (token.comment && options.includeComments) {
          lines.push(`      comment: "${token.comment}"`);
        }
        
        if (token.deprecated) {
          lines.push(`      deprecated: true`);
        }
      }
    }

    return lines.join('\n');
  }

  /**
   * Generate Tailwind CSS configuration
   */
  private generateTailwindConfig(tokens: TokenDefinition[], options: ExportOptions): string {
    const lines: string[] = [];

    lines.push('/**');
    lines.push(' * Design System Tokens - Tailwind Config');
    lines.push(` * Generated: ${new Date().toISOString()}`);
    lines.push(' * DO NOT EDIT - This file is automatically generated');
    lines.push(' */');
    lines.push('');

    lines.push('module.exports = {');
    lines.push('  theme: {');
    lines.push('    extend: {');

    // Colors
    const colorTokens = tokens.filter(t => t.type === 'color');
    if (colorTokens.length > 0) {
      lines.push('      colors: {');
      for (const token of colorTokens) {
        const key = token.name.replace(/-/g, '');
        lines.push(`        '${key}': '${token.value}',`);
      }
      lines.push('      },');
    }

    // Spacing
    const spacingTokens = tokens.filter(t => t.type === 'spacing');
    if (spacingTokens.length > 0) {
      lines.push('      spacing: {');
      for (const token of spacingTokens) {
        const key = token.name.replace(/^spacing-/, '');
        lines.push(`        '${key}': '${token.value}',`);
      }
      lines.push('      },');
    }

    // Font sizes
    const fontSizeTokens = tokens.filter(t => t.type === 'fontSize');
    if (fontSizeTokens.length > 0) {
      lines.push('      fontSize: {');
      for (const token of fontSizeTokens) {
        const key = token.name.replace(/^font-size-/, '');
        lines.push(`        '${key}': '${token.value}',`);
      }
      lines.push('      },');
    }

    // Border radius
    const radiusTokens = tokens.filter(t => t.type === 'borderRadius');
    if (radiusTokens.length > 0) {
      lines.push('      borderRadius: {');
      for (const token of radiusTokens) {
        const key = token.name.replace(/^radius-/, '');
        lines.push(`        '${key}': '${token.value}',`);
      }
      lines.push('      },');
    }

    lines.push('    },');
    lines.push('  },');
    lines.push('};');

    return lines.join('\n');
  }

  /**
   * Group tokens by category
   */
  private groupByCategory(tokens: TokenDefinition[]): Record<string, TokenDefinition[]> {
    const groups: Record<string, TokenDefinition[]> = {};

    for (const token of tokens) {
      if (!groups[token.category]) {
        groups[token.category] = [];
      }
      groups[token.category].push(token);
    }

    return groups;
  }

  /**
   * Convert kebab-case to camelCase
   */
  private toCamelCase(str: string): string {
    return str.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
  }

  /**
   * Minify content
   */
  private minify(content: string, format: 'css' | 'js'): string {
    if (format === 'css') {
      return content
        .replace(/\/\*[^*]*\*+(?:[^/*][^*]*\*+)*\//g, '') // Remove comments
        .replace(/\s+/g, ' ') // Collapse whitespace
        .replace(/;\s*}/g, '}') // Remove semicolon before closing brace
        .trim();
    }

    if (format === 'js') {
      return content
        .replace(/\/\*[^*]*\*+(?:[^/*][^*]*\*+)*\//g, '') // Remove comments
        .replace(/\/\/.*$/gm, '') // Remove line comments
        .replace(/\s+/g, ' ') // Collapse whitespace
        .trim();
    }

    return content;
  }

  /**
   * Ensure output directory exists
   */
  private ensureOutputDir(): void {
    if (!existsSync(this.outputDir)) {
      mkdirSync(this.outputDir, { recursive: true });
    }
  }
}