{
  "contentType": "written-material",
  "lessonId": "lesson-4-1",
  "content": {
    "format": "html",
    "title": "Secure Software Development Lifecycle",
    "pages": [
      {
        "pageNumber": 1,
        "content": "<h1>Building Security In: The Secure SDLC</h1><p>The most expensive vulnerability is the one that makes it to production. While penetration testing and security patches have their place, the most effective security strategy is to build security into software from the beginning. This lesson explores how to integrate security throughout the Software Development Lifecycle (SDLC), turning security from a last-minute checkbox into a fundamental design principle.</p><h2>The Cost of Insecurity</h2><p>The later a vulnerability is found, the more expensive it is to fix:</p><ul><li><strong>Design phase:</strong> $1 to fix</li><li><strong>Implementation:</strong> $10 to fix</li><li><strong>Testing:</strong> $100 to fix</li><li><strong>Production:</strong> $1,000+ to fix</li><li><strong>After breach:</strong> $10,000+ (including reputation damage)</li></ul><h2>Traditional vs. Secure SDLC</h2><table><tr><th>Traditional SDLC</th><th>Secure SDLC</th></tr><tr><td>Security as final gate</td><td>Security at every phase</td></tr><tr><td>Penetration test before release</td><td>Continuous security testing</td></tr><tr><td>Developers vs. Security team</td><td>Shared security responsibility</td></tr><tr><td>Fix vulnerabilities</td><td>Prevent vulnerabilities</td></tr><tr><td>Security slows delivery</td><td>Security enables faster delivery</td></tr></table><h2>The DevSecOps Revolution</h2><p>DevSecOps shifts security left, making it everyone's responsibility:</p><ul><li><strong>Dev:</strong> Developers write secure code</li><li><strong>Sec:</strong> Security is automated and integrated</li><li><strong>Ops:</strong> Operations maintains security in production</li></ul>"
      },
      {
        "pageNumber": 2,
        "content": "<h2>Phase 1: Secure Planning and Requirements</h2><p>Security begins before a single line of code is written.</p><h3>Security Requirements Gathering</h3><ul><li><strong>Regulatory requirements:</strong> GDPR, HIPAA, PCI DSS</li><li><strong>Data classification:</strong> What sensitive data will you handle?</li><li><strong>Authentication needs:</strong> Who needs access to what?</li><li><strong>Compliance obligations:</strong> Industry standards</li><li><strong>Privacy requirements:</strong> Data minimization, consent</li></ul><h3>Risk Assessment</h3><p>Identify threats early:</p><ol><li>What assets are we protecting?</li><li>Who might attack us and why?</li><li>What would be the impact of a breach?</li><li>What security controls do we need?</li></ol><h3>Security User Stories</h3><p>Make security requirements explicit:</p><ul><li>\"As a user, I want my password to be stored securely so that it cannot be stolen if the database is breached\"</li><li>\"As an admin, I want all API calls to be logged so that I can detect suspicious activity\"</li><li>\"As a customer, I want my payment data to be tokenized so that the application never stores my credit card\"</li></ul><h3>Abuse Cases</h3><p>Think like an attacker:</p><ul><li>\"As an attacker, I want to inject SQL to steal user data\"</li><li>\"As a malicious user, I want to access other users' accounts\"</li><li>\"As a competitor, I want to scrape all product data\"</li></ul><h3>Security Architecture Review</h3><p>Before implementation begins:</p><ul><li>Threat modeling sessions</li><li>Architecture security review</li><li>Technology stack evaluation</li><li>Third-party component assessment</li></ul>"
      },
      {
        "pageNumber": 3,
        "content": "<h2>Phase 2: Secure Design</h2><h3>Threat Modeling</h3><p>Systematic approach to finding security flaws in design:</p><h4>STRIDE Framework</h4><ul><li><strong>S</strong>poofing: Can someone pretend to be another user?</li><li><strong>T</strong>ampering: Can data be maliciously modified?</li><li><strong>R</strong>epudiation: Can users deny their actions?</li><li><strong>I</strong>nformation Disclosure: Can confidential data leak?</li><li><strong>D</strong>enial of Service: Can the system be made unavailable?</li><li><strong>E</strong>levation of Privilege: Can users gain unauthorized permissions?</li></ul><h4>Data Flow Diagrams</h4><p>Map how data moves through your system:</p><ol><li>Identify all data stores</li><li>Show all data flows</li><li>Mark trust boundaries</li><li>Find where data crosses boundaries</li><li>Apply STRIDE to each element</li></ol><h3>Security Design Principles</h3><ol><li><strong>Least Privilege:</strong> Give minimum necessary permissions</li><li><strong>Defense in Depth:</strong> Multiple security layers</li><li><strong>Fail Securely:</strong> Errors shouldn't expose sensitive data</li><li><strong>Don't Trust Input:</strong> Validate everything</li><li><strong>Separation of Duties:</strong> No single point of compromise</li><li><strong>Avoid Security by Obscurity:</strong> Assume attackers know your system</li><li><strong>Keep It Simple:</strong> Complexity breeds vulnerabilities</li></ol><h3>Secure Design Patterns</h3><ul><li><strong>Authentication Gateway:</strong> Centralized authentication</li><li><strong>Input Validation:</strong> Whitelist acceptable input</li><li><strong>Output Encoding:</strong> Prevent injection attacks</li><li><strong>Secure Session Management:</strong> Proper timeout and rotation</li><li><strong>Audit Logging:</strong> Record security-relevant events</li></ul>"
      },
      {
        "pageNumber": 4,
        "content": "<h2>Phase 3: Secure Implementation</h2><h3>Secure Coding Standards</h3><p>Language-specific guidelines for secure code:</p><h4>Input Validation</h4><pre>// Bad\nString query = \"SELECT * FROM users WHERE id = \" + request.getParameter(\"id\");\n\n// Good\nString query = \"SELECT * FROM users WHERE id = ?\";\nPreparedStatement pstmt = connection.prepareStatement(query);\npstmt.setString(1, request.getParameter(\"id\"));</pre><h4>Output Encoding</h4><pre>// Bad\n<div>Hello <%= username %></div>\n\n// Good\n<div>Hello <%= HtmlUtils.htmlEscape(username) %></div></pre><h3>Common Vulnerability Prevention</h3><h4>SQL Injection</h4><ul><li>Use parameterized queries always</li><li>Stored procedures with parameters</li><li>Input validation as defense in depth</li><li>Least privilege database accounts</li></ul><h4>Cross-Site Scripting (XSS)</h4><ul><li>Context-aware output encoding</li><li>Content Security Policy headers</li><li>Framework auto-escaping features</li><li>HTTPOnly cookies</li></ul><h4>Authentication Flaws</h4><ul><li>Strong password requirements</li><li>Secure password storage (bcrypt/Argon2)</li><li>Account lockout mechanisms</li><li>Multi-factor authentication</li></ul><h3>Security Libraries and Frameworks</h3><p>Don't reinvent the wheel:</p><ul><li><strong>Authentication:</strong> Spring Security, Passport.js</li><li><strong>Crypto:</strong> Bouncy Castle, libsodium</li><li><strong>Input Validation:</strong> OWASP Java Encoder, DOMPurify</li><li><strong>Security Headers:</strong> Helmet.js</li></ul><h3>Dependency Management</h3><ul><li>Track all third-party components</li><li>Monitor for vulnerabilities (npm audit, OWASP Dependency Check)</li><li>Update regularly but test thoroughly</li><li>Consider security in selection criteria</li></ul>"
      },
      {
        "pageNumber": 5,
        "content": "<h2>Phase 4: Security Testing</h2><h3>Static Application Security Testing (SAST)</h3><p>Analyze source code for vulnerabilities:</p><ul><li><strong>When:</strong> Every commit, pull request</li><li><strong>Tools:</strong> SonarQube, Checkmarx, Fortify</li><li><strong>Benefits:</strong> Find issues early, exact location</li><li><strong>Limitations:</strong> False positives, can't find runtime issues</li></ul><h3>Dynamic Application Security Testing (DAST)</h3><p>Test running application:</p><ul><li><strong>When:</strong> Staging environment, before release</li><li><strong>Tools:</strong> OWASP ZAP, Burp Suite, Acunetix</li><li><strong>Benefits:</strong> Finds runtime issues, configuration problems</li><li><strong>Limitations:</strong> Needs running app, may miss code paths</li></ul><h3>Interactive Application Security Testing (IAST)</h3><p>Combines SAST and DAST:</p><ul><li>Instruments application</li><li>Monitors from inside during testing</li><li>More accurate than SAST or DAST alone</li></ul><h3>Security Unit Tests</h3><pre>@Test\npublic void testSQLInjectionPrevention() {\n    String maliciousInput = \"'; DROP TABLE users; --\";\n    User result = userDao.findById(maliciousInput);\n    assertNull(result);\n    // Verify table still exists\n    assertTrue(userDao.tableExists(\"users\"));\n}</pre><h3>Penetration Testing</h3><ul><li><strong>Scope:</strong> Define what's in/out of scope</li><li><strong>Approach:</strong> Black box, white box, or gray box</li><li><strong>Timing:</strong> Before major releases</li><li><strong>Follow-up:</strong> Fix findings, retest</li></ul><h3>Security Regression Testing</h3><ul><li>Add tests for every vulnerability found</li><li>Ensure fixes don't get undone</li><li>Build security test suite over time</li></ul>"
      },
      {
        "pageNumber": 6,
        "content": "<h2>Phase 5: Secure Deployment and Operations</h2><h3>Secure Deployment Pipeline</h3><ol><li><strong>Code commit:</strong> SAST scan, dependency check</li><li><strong>Build:</strong> Security tests, license compliance</li><li><strong>Deploy to staging:</strong> DAST scan, configuration review</li><li><strong>Production deploy:</strong> Final security gates</li><li><strong>Post-deploy:</strong> Security monitoring activated</li></ol><h3>Infrastructure as Code Security</h3><pre># Terraform example with security\nresource \"aws_s3_bucket\" \"data\" {\n  bucket = \"my-secure-bucket\"\n  \n  server_side_encryption_configuration {\n    rule {\n      apply_server_side_encryption_by_default {\n        sse_algorithm = \"AES256\"\n      }\n    }\n  }\n  \n  versioning {\n    enabled = true\n  }\n  \n  logging {\n    target_bucket = aws_s3_bucket.log_bucket.id\n    target_prefix = \"log/\"\n  }\n}</pre><h3>Security Monitoring</h3><ul><li><strong>Application logs:</strong> Authentication failures, access violations</li><li><strong>Security Information and Event Management (SIEM)</strong></li><li><strong>Intrusion Detection Systems</strong></li><li><strong>File Integrity Monitoring</strong></li><li><strong>Anomaly detection:</strong> Unusual patterns</li></ul><h3>Incident Response</h3><ol><li><strong>Preparation:</strong> Runbooks, contact lists</li><li><strong>Detection:</strong> Monitoring and alerts</li><li><strong>Containment:</strong> Isolate affected systems</li><li><strong>Eradication:</strong> Remove the threat</li><li><strong>Recovery:</strong> Restore normal operations</li><li><strong>Lessons Learned:</strong> Improve defenses</li></ol><h2>Security Metrics</h2><p>Measure your security program:</p><ul><li><strong>Mean Time to Detect (MTTD)</strong></li><li><strong>Mean Time to Respond (MTTR)</strong></li><li><strong>Vulnerability density:</strong> Vulns per 1000 lines of code</li><li><strong>Patch time:</strong> Time from disclosure to patch</li><li><strong>Security training completion rates</strong></li><li><strong>False positive rates in security tools</strong></li></ul><h2>Key Takeaways</h2><ul><li>Security must be built in, not bolted on</li><li>Every phase of SDLC has security activities</li><li>Automation enables security at speed</li><li>Developers need security training and tools</li><li>Shift left but secure right too</li><li>Measure and improve continuously</li><li>Security is everyone's responsibility</li></ul>"
      }
    ],
    "estimatedReadTime": 40,
    "totalPages": 6
  }
}