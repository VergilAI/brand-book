{
  "contentType": "written-material",
  "lessonId": "lesson-3-2",
  "content": {
    "format": "html",
    "title": "Applied Cryptography in Practice",
    "pages": [
      {
        "pageNumber": 1,
        "content": "<h1>From Theory to Practice: Implementing Cryptography</h1><p>Understanding cryptographic theory is essential, but implementing it correctly is where security succeeds or fails. This lesson bridges the gap between cryptographic concepts and real-world applications, showing you how encryption protects your daily digital interactions and how to implement it properly.</p><h2>Cryptography in Your Daily Life</h2><p>You use cryptography dozens of times daily, often without realizing it:</p><ul><li><strong>Morning:</strong> Phone's face unlock (biometric hashing)</li><li><strong>Commute:</strong> Contactless payment (NFC + encryption)</li><li><strong>Work login:</strong> Password hashing, MFA tokens</li><li><strong>Browsing:</strong> HTTPS connections</li><li><strong>Messaging:</strong> End-to-end encrypted chats</li><li><strong>Evening:</strong> Streaming services (DRM encryption)</li></ul><h2>The Implementation Challenge</h2><p>Strong algorithms can be weakened by poor implementation:</p><ul><li><strong>Sony PlayStation 3:</strong> Used constant instead of random number</li><li><strong>Debian OpenSSL:</strong> Weak random number generator (2008)</li><li><strong>WEP WiFi:</strong> IV reuse made it crackable</li><li><strong>Zoom:</strong> Claimed end-to-end encryption when it wasn't</li></ul><p>These failures show that cryptography is only as strong as its weakest implementation.</p>"
      },
      {
        "pageNumber": 2,
        "content": "<h2>HTTPS: Cryptography in Action</h2><p>Let's dissect what happens when you visit a secure website:</p><h3>The TLS Handshake Dance</h3><ol><li><strong>Client Hello:</strong><ul><li>Supported TLS versions</li><li>Cipher suites (algorithm combinations)</li><li>Random number</li></ul></li><li><strong>Server Hello:</strong><ul><li>Chosen TLS version</li><li>Selected cipher suite</li><li>Certificate</li><li>Server random number</li></ul></li><li><strong>Key Exchange:</strong><ul><li>Client verifies certificate</li><li>Generate pre-master secret</li><li>Derive session keys</li></ul></li><li><strong>Encrypted Communication:</strong><ul><li>All data now encrypted with session keys</li><li>Uses symmetric encryption (fast)</li><li>Integrity checked with HMAC</li></ul></li></ol><h3>Perfect Forward Secrecy</h3><p>Modern TLS uses ephemeral keys:</p><ul><li>New keys for each session</li><li>Past communications stay secure even if long-term keys compromised</li><li>Implemented via DHE or ECDHE</li></ul><h3>Certificate Validation Process</h3><pre>1. Check certificate validity dates\n2. Verify certificate chain to trusted root\n3. Check certificate hasn't been revoked\n4. Verify domain matches certificate\n5. Check for certificate transparency logs</pre><h3>Common HTTPS Misconfigurations</h3><ul><li>Mixed content (HTTP resources on HTTPS page)</li><li>Weak cipher suites enabled</li><li>Missing security headers (HSTS)</li><li>Certificate chain problems</li><li>Supporting obsolete protocols</li></ul>"
      },
      {
        "pageNumber": 3,
        "content": "<h2>Password Security: Beyond Basic Hashing</h2><p>Storing passwords securely is cryptography 101, yet breaches regularly expose millions of poorly protected passwords.</p><h3>Evolution of Password Storage</h3><ol><li><strong>Plaintext:</strong> Never acceptable</li><li><strong>Simple hashing:</strong> MD5/SHA1 - easily cracked</li><li><strong>Salted hashes:</strong> Better, prevents rainbow tables</li><li><strong>Key derivation functions:</strong> Modern best practice</li></ol><h3>Modern Password Hashing</h3><h4>bcrypt</h4><pre>$2b$12$EXRkfkdmXn2gzds2SSitu.MW9.gAVqa9eLS1//RYtYCmB1eLHg.9q\n└┬┘└┬┘└──────────────salt───────────────┘└────────hash────────┘\nalg cost</pre><ul><li>Adaptive: Increase cost factor as computers get faster</li><li>Built-in salt generation</li><li>Resistant to timing attacks</li></ul><h4>Argon2</h4><p>Winner of Password Hashing Competition:</p><ul><li><strong>Argon2i:</strong> Resistant to side-channel attacks</li><li><strong>Argon2d:</strong> Resistant to GPU cracking</li><li><strong>Argon2id:</strong> Hybrid approach (recommended)</li></ul><h4>PBKDF2</h4><ul><li>NIST approved</li><li>Configurable iteration count</li><li>Used in many enterprise systems</li></ul><h3>Password Security Best Practices</h3><ol><li><strong>Never roll your own:</strong> Use established libraries</li><li><strong>Salt everything:</strong> Unique salt per password</li><li><strong>Tune work factors:</strong> Balance security and performance</li><li><strong>Secure password reset:</strong> Often the weakest link</li><li><strong>Consider passwordless:</strong> FIDO2, biometrics</li></ol><h3>Multi-Factor Authentication</h3><p>Something you know + something you have + something you are</p><ul><li><strong>TOTP:</strong> Time-based one-time passwords</li><li><strong>FIDO2:</strong> Public key authentication</li><li><strong>SMS:</strong> Weakest option (SIM swapping risk)</li></ul>"
      },
      {
        "pageNumber": 4,
        "content": "<h2>Secure Communication Protocols</h2><h3>Email Encryption: Why It Failed</h3><p>Despite PGP existing since 1991, encrypted email never went mainstream:</p><ul><li><strong>Usability:</strong> Key management too complex</li><li><strong>Network effects:</strong> Need others to use it</li><li><strong>Metadata:</strong> Headers remain unencrypted</li><li><strong>Forward secrecy:</strong> PGP lacks it</li></ul><h3>Messaging: The E2E Revolution</h3><h4>Signal Protocol Success</h4><p>What Signal got right:</p><ul><li>Automatic key exchange</li><li>Perfect forward secrecy</li><li>Future secrecy (post-compromise security)</li><li>Transparent to users</li></ul><h4>Double Ratchet Algorithm</h4><ol><li>Diffie-Hellman ratchet for key agreement</li><li>Symmetric ratchet for message keys</li><li>New keys for every message</li><li>Compromise recovery built-in</li></ol><h3>VPN Protocols</h3><h4>OpenVPN</h4><ul><li>Uses OpenSSL library</li><li>Highly configurable</li><li>UDP or TCP transport</li><li>Industry standard</li></ul><h4>WireGuard</h4><ul><li>Modern, minimal protocol</li><li>Faster than OpenVPN</li><li>Smaller attack surface</li><li>Built into Linux kernel</li></ul><h4>IPSec vs SSL VPNs</h4><table><tr><th>Feature</th><th>IPSec</th><th>SSL VPN</th></tr><tr><td>Layer</td><td>Network (Layer 3)</td><td>Application (Layer 7)</td></tr><tr><td>Client</td><td>Often needs software</td><td>Browser-based possible</td></tr><tr><td>Firewall friendly</td><td>No</td><td>Yes</td></tr><tr><td>Performance</td><td>Better</td><td>Good</td></tr></table>"
      },
      {
        "pageNumber": 5,
        "content": "<h2>Cryptographic Key Management</h2><p>The hardest part of cryptography isn't the math - it's managing keys securely.</p><h3>Key Lifecycle Management</h3><ol><li><strong>Generation:</strong> Use true randomness</li><li><strong>Distribution:</strong> Secure channels only</li><li><strong>Storage:</strong> Hardware security modules (HSM)</li><li><strong>Usage:</strong> Limit scope and permissions</li><li><strong>Rotation:</strong> Regular key changes</li><li><strong>Revocation:</strong> Quick invalidation process</li><li><strong>Destruction:</strong> Secure deletion</li></ol><h3>Key Storage Solutions</h3><h4>Hardware Security Modules (HSM)</h4><ul><li>Tamper-resistant hardware</li><li>Keys never leave in plaintext</li><li>FIPS 140-2 Level 3/4 certified</li><li>Used by banks, CAs</li></ul><h4>Key Management Services (Cloud)</h4><ul><li><strong>AWS KMS:</strong> Integrated with AWS services</li><li><strong>Azure Key Vault:</strong> Secrets and certificate management</li><li><strong>Google Cloud KMS:</strong> Supports external keys</li><li><strong>HashiCorp Vault:</strong> Open source option</li></ul><h4>Software-Based Storage</h4><ul><li>Operating system key stores</li><li>Application-specific keystores</li><li>Encrypted databases</li><li>Risk: Keys in memory</li></ul><h3>Common Key Management Mistakes</h3><ol><li><strong>Hardcoded keys:</strong> In source code or config files</li><li><strong>Shared keys:</strong> Same key across environments</li><li><strong>No rotation:</strong> Years-old keys still in use</li><li><strong>Poor access control:</strong> Everyone has access</li><li><strong>No audit trail:</strong> Can't track key usage</li><li><strong>Weak generation:</strong> Predictable randomness</li></ol><h3>API Key Security</h3><pre>// Bad\nconst API_KEY = 'sk_live_abcd1234';\n\n// Good\nconst API_KEY = process.env.API_KEY;</pre><ul><li>Never commit keys to repositories</li><li>Use environment variables</li><li>Implement key rotation</li><li>Scope keys minimally</li><li>Monitor for exposed keys</li></ul>"
      },
      {
        "pageNumber": 6,
        "content": "<h2>Cryptography Implementation Checklist</h2><h3>Algorithm Selection</h3>☐ Use established algorithms (AES, RSA-2048+, SHA-256+)<br>☐ Avoid deprecated algorithms (DES, MD5, SHA-1)<br>☐ Plan for crypto-agility (ability to change algorithms)<br>☐ Consider quantum resistance for long-term data<h3>Random Number Generation</h3>☐ Use OS crypto random (/dev/urandom, CryptGenRandom)<br>☐ Never use predictable sources (time, PIDs)<br>☐ Seed properly in virtual environments<br>☐ Test randomness quality<h3>Key Management</h3>☐ Generate keys with sufficient entropy<br>☐ Store keys separately from data<br>☐ Implement key rotation schedule<br>☐ Use HSM/KMS for sensitive keys<br>☐ Document key recovery procedures<h3>Implementation Security</h3>☐ Use established crypto libraries<br>☐ Keep libraries updated<br>☐ Enable all security features<br>☐ Implement proper error handling<br>☐ Protect against timing attacks<h3>Testing and Validation</h3>☐ Test with known test vectors<br>☐ Perform negative testing<br>☐ Audit by security professionals<br>☐ Monitor for crypto-related CVEs<br>☐ Plan for algorithm migration<h2>Future-Proofing Your Cryptography</h2><h3>Crypto-Agility</h3><p>Design systems to change algorithms without major rewrites:</p><ul><li>Abstract cryptographic operations</li><li>Version your encrypted data</li><li>Support multiple algorithms during transition</li><li>Test migration procedures</li></ul><h3>Post-Quantum Preparation</h3><ol><li>Inventory current crypto usage</li><li>Identify quantum-vulnerable systems</li><li>Increase symmetric key sizes now</li><li>Follow NIST post-quantum standards</li><li>Plan hybrid approaches</li></ol><h2>Key Takeaways</h2><ul><li>Implementation matters as much as algorithm choice</li><li>Key management is the hardest part</li><li>Use established libraries and protocols</li><li>Plan for crypto-agility</li><li>Security is a process, not a product</li><li>Stay informed about new vulnerabilities</li><li>Test, audit, and monitor continuously</li></ul>"
      }
    ],
    "estimatedReadTime": 40,
    "totalPages": 6
  }
}