{
  "contentType": "written-material",
  "lessonId": "lesson-4-2",
  "content": {
    "format": "html",
    "title": "Web Application Security",
    "pages": [
      {
        "pageNumber": 1,
        "content": "<h1>Web Application Security: Defending the Digital Frontline</h1><p>Web applications are the primary interface between organizations and their users, making them prime targets for attackers. From online banking to social media, these applications handle sensitive data and critical transactions. This lesson explores the unique security challenges of web applications and provides practical defenses against the most common attacks.</p><h2>The Web Security Landscape</h2><p>Web applications face unique challenges:</p><ul><li><strong>Public exposure:</strong> Accessible to anyone on the internet</li><li><strong>Complex stack:</strong> Browser, network, server, database</li><li><strong>Multiple technologies:</strong> HTML, CSS, JavaScript, backend languages</li><li><strong>User input:</strong> Every form field is a potential attack vector</li><li><strong>Session management:</strong> HTTP is stateless by design</li><li><strong>Third-party integration:</strong> APIs, libraries, services</li></ul><h2>OWASP Top 10: Know Your Enemy</h2><p>The Open Web Application Security Project (OWASP) maintains the definitive list of web application security risks:</p><ol><li>Broken Access Control</li><li>Cryptographic Failures</li><li>Injection</li><li>Insecure Design</li><li>Security Misconfiguration</li><li>Vulnerable Components</li><li>Authentication Failures</li><li>Data Integrity Failures</li><li>Security Logging Failures</li><li>Server-Side Request Forgery</li></ol><p>Understanding these risks is the first step in defending against them.</p>"
      },
      {
        "pageNumber": 2,
        "content": "<h2>Injection Attacks: The Classic Threat</h2><h3>SQL Injection</h3><p>Still the king of web vulnerabilities, SQL injection occurs when user input is incorporated into SQL queries without proper sanitization.</p><h4>Vulnerable Code:</h4><pre>username = request.POST['username']\npassword = request.POST['password']\nquery = f\"SELECT * FROM users WHERE username='{username}' AND password='{password}'\"\n# Attacker input: admin' --\n# Resulting query: SELECT * FROM users WHERE username='admin' --' AND password=''</pre><h4>Defense Strategies:</h4><ol><li><strong>Parameterized Queries (Best):</strong><pre>cursor.execute(\n    \"SELECT * FROM users WHERE username=? AND password=?\",\n    (username, password)\n)</pre></li><li><strong>Stored Procedures:</strong> Pre-compiled SQL with parameters</li><li><strong>Input Validation:</strong> Whitelist acceptable characters</li><li><strong>Least Privilege:</strong> Database user with minimal permissions</li><li><strong>WAF Rules:</strong> Block common SQL injection patterns</li></ol><h3>Command Injection</h3><p>When applications execute system commands with user input:</p><pre># Vulnerable\nos.system(f\"ping {user_input}\")\n# Attack: google.com; rm -rf /\n\n# Secure\nimport subprocess\nsubprocess.run([\"ping\", user_input], shell=False)</pre><h3>LDAP, XML, and Other Injections</h3><p>Same principle, different contexts:</p><ul><li><strong>LDAP:</strong> Escape special characters in LDAP queries</li><li><strong>XML:</strong> Use XML parsers, not string concatenation</li><li><strong>NoSQL:</strong> Yes, even NoSQL databases can be injected</li><li><strong>Template:</strong> Server-side template injection in Jinja2, etc.</li></ul>"
      },
      {
        "pageNumber": 3,
        "content": "<h2>Cross-Site Scripting (XSS): JavaScript Gone Wild</h2><p>XSS occurs when untrusted data is included in web pages without proper validation or escaping.</p><h3>Types of XSS</h3><h4>1. Reflected XSS</h4><ul><li>Malicious script in URL parameter</li><li>Immediately reflected back to user</li><li>Example: <code>site.com/search?q=<script>alert('XSS')</script></code></li></ul><h4>2. Stored XSS</h4><ul><li>Malicious script stored in database</li><li>Executed when other users view content</li><li>More dangerous - affects multiple users</li></ul><h4>3. DOM-based XSS</h4><ul><li>Vulnerability in client-side JavaScript</li><li>Never touches the server</li><li>Example: <code>document.write(location.href)</code></li></ul><h3>XSS Defense in Depth</h3><ol><li><strong>Output Encoding:</strong><pre><!-- HTML context -->\n&lt;div&gt;{{user_input | html_escape}}&lt;/div&gt;\n\n<!-- JavaScript context -->\n&lt;script&gt;var name = '{{user_input | js_escape}}';&lt;/script&gt;\n\n<!-- URL context -->\n&lt;a href=\"/user/{{user_input | url_escape}}\"&gt;Link&lt;/a&gt;</pre></li><li><strong>Content Security Policy (CSP):</strong><pre>Content-Security-Policy: \n  default-src 'self';\n  script-src 'self' 'nonce-random123';\n  style-src 'self' 'unsafe-inline';</pre></li><li><strong>HTTPOnly Cookies:</strong> Prevent JavaScript access to session cookies</li><li><strong>X-XSS-Protection:</strong> Enable browser XSS filters</li><li><strong>Input Validation:</strong> Reject suspicious input patterns</li></ol><h3>Modern Framework Protections</h3><ul><li><strong>React:</strong> Escapes by default, dangerouslySetInnerHTML for raw HTML</li><li><strong>Angular:</strong> Automatic sanitization, explicit trust required</li><li><strong>Vue.js:</strong> v-html directive for raw HTML, escaped by default</li></ul>"
      },
      {
        "pageNumber": 4,
        "content": "<h2>Authentication and Session Management</h2><h3>Broken Authentication</h3><p>Common authentication vulnerabilities:</p><ul><li><strong>Weak passwords:</strong> No complexity requirements</li><li><strong>Credential stuffing:</strong> Reused passwords from breaches</li><li><strong>Session fixation:</strong> Attacker sets victim's session ID</li><li><strong>Weak forgot password:</strong> Guessable security questions</li></ul><h3>Secure Authentication Implementation</h3><h4>Password Requirements</h4><ul><li>Minimum 12 characters (longer is better)</li><li>No common passwords (use lists like SecLists)</li><li>Check against breach databases (HaveIBeenPwned API)</li><li>Allow all characters including spaces</li><li>Show password strength meter</li></ul><h4>Secure Password Storage</h4><pre># Python example with bcrypt\nimport bcrypt\n\n# Registration\npassword = request.form['password'].encode('utf-8')\nhashed = bcrypt.hashpw(password, bcrypt.gensalt(rounds=12))\n\n# Login\nif bcrypt.checkpw(password, stored_hash):\n    # Password correct\n    create_session()</pre><h4>Multi-Factor Authentication</h4><ol><li><strong>TOTP (Time-based One-Time Password):</strong><ul><li>Google Authenticator compatible</li><li>Backup codes for recovery</li></ul></li><li><strong>WebAuthn/FIDO2:</strong><ul><li>Hardware keys or biometrics</li><li>Phishing resistant</li></ul></li><li><strong>SMS (Avoid if possible):</strong><ul><li>Vulnerable to SIM swapping</li><li>Better than nothing</li></ul></li></ol><h3>Session Management</h3><h4>Secure Session Configuration</h4><pre># Secure cookie settings\nresponse.set_cookie(\n    'session_id',\n    value=session_token,\n    secure=True,        # HTTPS only\n    httponly=True,      # No JavaScript access\n    samesite='Strict',  # CSRF protection\n    max_age=1800        # 30 minute timeout\n)</pre><h4>Session Security Best Practices</h4><ul><li>Generate new session ID on login</li><li>Invalidate session on logout</li><li>Implement absolute and idle timeouts</li><li>Bind sessions to IP/User-Agent (carefully)</li><li>Store sessions server-side (Redis, database)</li></ul>"
      },
      {
        "pageNumber": 5,
        "content": "<h2>Access Control and Authorization</h2><h3>Broken Access Control</h3><p>The #1 issue in OWASP Top 10 2021. Examples:</p><ul><li>Changing user ID in URL to access other accounts</li><li>Elevation of privilege through parameter tampering</li><li>Accessing admin functions through forced browsing</li><li>CORS misconfiguration allowing unauthorized API access</li></ul><h3>Implementing Proper Access Control</h3><h4>1. Principle of Least Privilege</h4><pre># Bad - checking on client side only\n@app.route('/admin')\ndef admin_panel():\n    return render_template('admin.html')\n\n# Good - server-side authorization\n@app.route('/admin')\n@require_role('admin')\ndef admin_panel():\n    return render_template('admin.html')</pre><h4>2. Role-Based Access Control (RBAC)</h4><ul><li>Define roles (admin, user, moderator)</li><li>Assign permissions to roles</li><li>Assign users to roles</li><li>Check permissions on every request</li></ul><h4>3. Attribute-Based Access Control (ABAC)</h4><p>More flexible than RBAC:</p><pre>// Can user edit this document?\nif (user.department === document.department && \n    user.clearanceLevel >= document.classificationLevel &&\n    document.status !== 'archived') {\n    allow_edit();\n}</pre><h3>CORS (Cross-Origin Resource Sharing)</h3><p>Control which domains can access your APIs:</p><pre># Too permissive - allows any origin\nAccess-Control-Allow-Origin: *\n\n# Better - whitelist specific origins\nif origin in ['https://app.example.com', 'https://www.example.com']:\n    response.headers['Access-Control-Allow-Origin'] = origin\n    response.headers['Access-Control-Allow-Credentials'] = 'true'</pre><h3>API Security</h3><ul><li><strong>Authentication:</strong> API keys, OAuth tokens, JWT</li><li><strong>Rate limiting:</strong> Prevent abuse and DDoS</li><li><strong>Input validation:</strong> Especially important for APIs</li><li><strong>Output filtering:</strong> Don't expose internal data</li><li><strong>Versioning:</strong> Maintain backward compatibility</li></ul>"
      },
      {
        "pageNumber": 6,
        "content": "<h2>Security Headers and Configuration</h2><h3>Essential Security Headers</h3><pre># Comprehensive security headers\nContent-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline'\nX-Frame-Options: DENY\nX-Content-Type-Options: nosniff\nReferrer-Policy: strict-origin-when-cross-origin\nPermissions-Policy: geolocation=(), microphone=(), camera=()\nStrict-Transport-Security: max-age=31536000; includeSubDomains; preload</pre><h3>HTTPS Configuration</h3><ul><li>Use TLS 1.2 minimum (prefer 1.3)</li><li>Strong cipher suites only</li><li>HSTS to prevent downgrade attacks</li><li>Certificate pinning for mobile apps</li><li>Monitor certificate expiration</li></ul><h3>Security Misconfiguration Prevention</h3><ol><li><strong>Remove defaults:</strong> Change default passwords, remove sample apps</li><li><strong>Minimal installation:</strong> Only install necessary components</li><li><strong>Directory listing:</strong> Disable in web server</li><li><strong>Error handling:</strong> Generic error messages in production</li><li><strong>Update regularly:</strong> OS, web server, frameworks, libraries</li></ol><h2>Web Application Firewalls (WAF)</h2><p>WAFs provide an additional layer of defense:</p><h3>WAF Capabilities</h3><ul><li>Block common attack patterns</li><li>Virtual patching for vulnerabilities</li><li>Rate limiting and DDoS protection</li><li>Geographic blocking</li><li>Bot detection and management</li></ul><h3>WAF Limitations</h3><ul><li>Not a substitute for secure coding</li><li>Can be bypassed with encoding/obfuscation</li><li>False positives can block legitimate traffic</li><li>Requires tuning and maintenance</li></ul><h2>Security Testing for Web Apps</h2><h3>Manual Testing Checklist</h3>☐ Test all input fields for injection<br>☐ Verify access controls on all endpoints<br>☐ Check session management implementation<br>☐ Test file upload restrictions<br>☐ Verify HTTPS and security headers<br>☐ Test error handling and information leakage<br>☐ Check for default credentials<br>☐ Test rate limiting and anti-automation<h3>Automated Security Scanning</h3><ul><li><strong>OWASP ZAP:</strong> Free, open-source scanner</li><li><strong>Burp Suite:</strong> Professional web app testing</li><li><strong>Nikto:</strong> Web server scanner</li><li><strong>SQLMap:</strong> Automated SQL injection</li></ul><h2>Key Takeaways</h2><ul><li>Never trust user input - validate everything</li><li>Use parameterized queries to prevent injection</li><li>Encode output based on context</li><li>Implement proper authentication and session management</li><li>Enforce access control on the server side</li><li>Use security headers and HTTPS</li><li>Keep all components updated</li><li>Regular security testing is essential</li><li>Defense in depth - multiple layers of security</li></ul>"
      }
    ],
    "estimatedReadTime": 45,
    "totalPages": 6
  }
}